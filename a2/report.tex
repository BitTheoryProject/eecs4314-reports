\documentclass[12pt, dvipsnames, a4paper]{article}
\usepackage{geometry}
\geometry{legalpaper, margin=0.5in}
\usepackage{xcolor}
\usepackage{lipsum,etoolbox}
\usepackage{xspace} 
\usepackage[normalem]{ulem}
\usepackage{vwcol}
\usepackage{cancel}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{caption}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{float}
\usepackage{multicol}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{textcomp}
\usepackage{lstautogobble}
\usepackage[parfill]{parskip}
\usepackage{tikz-qtree}
\usepackage{tikz}
\usepackage{hyperref}
\usetikzlibrary{decorations.pathreplacing}
\tikzset{every tree node/.style={minimum width=4cm,draw,circle},
         blank/.style={draw=none},
         edge from parent/.style=
         {draw,edge from parent path={(\tikzparentnode) -- (\tikzchildnode)}},
         level distance=1.5cm}

%% Genearl %%
\renewcommand{\thesection}{\arabic{section}}


%% For convenience %%
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\bcode}[1]{\texttt{\textbf{#1}}}
\newcommand{\balert}[1]{\textbf{\alert{#1}}}
\newcommand{\rarrow}{$\Rightarrow$}
\newcommand{\tab}[1][0.5cm]{\hspace*{#1}}
\newcommand{\deepemphasis}[1]{\underline{\textbf{\Large{#1}}}}
\newcommand{\bfemph}[1]{\textbf{\emph{#1}}}
\newcommand{\OR}[0]{\lvert \: \rvert}

%% Colours %%
\definecolor{mLightBrown}{HTML}{EB811B}
\definecolor{mLightGreen}{HTML}{14B03D}

%% Pseudocode %% 
\lstdefinelanguage{pseudo}
{
	keywords=[1]{
		let,
		class,
		new,
		loop,
		until,
		end,
		if,
		else,
		then,
		return,
		while,
		for,
		to,
		fun,
		break,
		and,
		true,
		false,
		or,
		do,
		max,
		min,
		elif,
	},
	keywordstyle=[1]\color{black}\bf,
	keywords=[2] {
		invariant,
		precond,
		postcond
	},
	keywordstyle=[2]\color{blue}\bf
}

\lstset{
	breaklines		=	true,
	language 		= 	pseudo,
	basicstyle		=	\ttfamily,
	mathescape		=	true,
	escapeinside	=	||,
	tabsize			=	2,
	numbers			=	left,
	commentstyle	=	\color{OliveGreen},
	stringstyle		=	\color{mLightBrown},
	upquote			=	true,
	morestring		=	[b]',
	moredelim		=	[l][\rmfamily\itshape]{@},
	comment			=	[l]{//},
	morecomment		=	[s]{/*}{*/},
	commentstyle=\color{Gray}\ttfamily,
	showstringspaces=	false,
	showtabs		=	false,
	autogobble
}

%% Other %%
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}

% \patchcmd{<cmd>}{<search>}{<replace>}{<success>}{<failure>}
\patchcmd{\abstract}{\titlepage}{\titlepage% Insert ToC-writing after starting a titlepage
  \addcontentsline{toc}{chapter}{Abstract}}{}{}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

% Keywords command
\providecommand{\keywords}[1]
{
  \small	
  \textbf{\textit{Keywords---}} #1
}


%**************************************************************************************************************%
%______________________________________________________________________________________________________________%
\begin{document}
\title{\textbf{EECS 4314 - Bit Theory\\Concrete Architecture Report}}
\date{\Large \today}
\author{
	\large \textbf{Amir Mohamad}\\ \small amohamad@my.yorku.ca\\\\
	\large \textbf{Arian Mohamad Hosaini}\\ \small mohama23@my.yorku.ca\\\\
	\large \textbf{Dante Laviolette}\\ \small dantelav@my.yorku.ca\\\\
	\large \textbf{Diego Santosuosso Salerno}\\ \small nicodemo@my.yorku.ca\\\\
	\large \textbf{Isaiah Linares}\\ \small isaiah88@my.yorku.ca\\\\
	\large \textbf{Joel Fagen}\\ \small joefagan@my.yorku.ca\\\\
	\large \textbf{Misato Shimizu}\\ \small misato1@my.yorku.ca\\\\
	\large \textbf{Muhammad Hassan}\\ \small furquanh@my.yorku.ca\\\\
	\large \textbf{Yi Qin}\\ \small aidenqin@my.yorku.ca\\\\
	\large \textbf{Zhilong Lin}\\ \small lzl1114@my.yorku.ca\\\\
	\large York University\\
}
\maketitle
\newpage
\hspace{0pt}
\vfill
\begin{abstract}
	\lipsum[1]
	\lipsum[1]
	\\\\
	\keywords{keyword1, keyword2, keyword3}
\end{abstract}
\vfill
\hspace{0pt}
\newpage
\tableofcontents
\clearpage

\section{Introduction}
\lipsum[1]

\section{Derivation Process}
\begin{figure}[!htb]
	\center
	\includegraphics[width = 390pt]{assets/derivation_diagram.png}
	\caption{Derivation process in a diagram}
\end{figure}
Unlike the process of understanding conceptual architecture, which requires mainly documentation reviews, understanding concrete architecture can be more challenging and complicated as it requires source code observations. To have better understanding of FreeBSD’s concrete architecture, we followed extraction steps, and they are shown as a derivation process in a figure above.
After downloading FreeBSD source code, we use a source code extractor (efx), Understand, which retrieves relations from the source code (e.g., control and data flow dependencies, relations among function calls). Here, we obtain a file, freebsd\_FileDependencies.csv which has been produced by Understand. By running a Perl command to convert the csv file into a raw.ta file using csv-to-ta.pl, software, called jGrok, figures out their subsystem relations. After filtering dependencies by running clean\_ignored.py, a graphical landscape editor, LSEdit, takes a role of visualizations for the extracted relations. Our task here is to manually observe those visualized diagrams in ls-edit.sh, and decompose subsystems hierarchically and pass the decomposed architectural structure to jGrok. We repeat these processes until we reach the point where the subsystem structure is understood in clear and detailed manners.

\section{Diagrams}
\lipsum[1]

\section{Architecture}
\subsection{Networking Inter-Process Communction}
The network IPC facilities are layed on top of the networking facilities, and this heavy coupling is shown in the conceptual architecture and confirmed in the concrete architecture we derived. Data from the application is sent through the socket layer to the networking layer, and data coming in flows from the networking layer through the socket, and then into the receiving application.  State required by the socket layer is fully encapsulated within it, whereas any protocol-related state is maintained in data structures that are specific to the supporting protocols. The system-call interface routines manage the actions related to a system call, collecting parameters, and converting user data into the format expected by the socket layer routine. Socket layer routines directly manipulate socket data structures and manage the synchronization between asynchronous activities.

\section{Reflextion Analysis}

\clearpage
\section{Use Cases}
\subsection{Piping In Shell}
The following sequence diagram shows how system calls can be used to pipe the
output of 1 application to the input of another in FreeBSD, using a shell
as an example program.
\begin{figure}[!htb]
	\advance\leftskip-0.5cm
	\includegraphics[width = 570pt]{assets/use_case_diagrams/pipe.pdf}
	\caption{Sequence diagram showing pipes being used in the shell for IPC. \cite{pipe}\cite{fork}\cite{wait}\cite{close}\cite{dup}\cite{execve}\cite{signal}\cite{pipe-explained}}
\end{figure}

\section{Data Dictionary}
\lipsum[1]

\section{Naming Conventions}
\lipsum[1]

\section{Conclusion}
In conclusion, the FreeBSD operating system has a powerful and flexible inter-process communication system which allows processes to communicate with each other, both through networks (Networking / Socket IPC) and within local computing environments (Single system / Local IPC). 

On one hand, the Socket or networking IPC is a mechanism for communication between processes running on the same system or on different systems connected over a network. In this sense, data from the applications flows through a socket and through a networking layer. The received data, which also comes from the networking layer through the socket, then goes into the application. With sockets, not only do processes not have to run on the same machine in order to communicate between them, they do not even have to run under the same operating system.

Three main types of sockets are supported by the FreeBSD operating system: (1) stream sockets, which provide a connection-oriented, sequential, reliable and bi-directional communication channel; (2) datagram sockets, which provide a message-oriented communication channel in a connectionless manner; and (3) raw sockets, which allow direct access to the low level protocols of the network layer and facilitate sending/receiving network packets.

On the other hand, the single system or local IPC includes an integrated environment of semaphores, message queues, pipes and shared memory regions. Semaphores serve as a synchronisation mechanism to allow different processes to access shared memory. Message queues, however, facilitate sending and receiving messages locally in a structured way. Along with pipes, they serve as a buffer that stores messages in a First-In-First-Out (FIFO) manner. These various mechanisms provide low-level access to regions of shared memory and sending/receiving messages between multiple processes. 

Overall, FreeBSD provides a variety of IPC mechanisms that allow processes to communicate and coordinate with each other efficiently, whether on the same system or across a network.

\section{Lessons Learned}
After studying the concrete architecture of the IPC (Inter-Process Communication) system of FreeBSD, some of the lessons learned include:

- \textbf{Lesson 1:} The interprocess communication system of FreeBSD is designed to be modular, flexible and scalable, which means that different communication mechanisms between processes can be implemented. This provides a powerful IPC system  for both local and networking environments.

- \textbf{Lesson 2:} As it includes mechanisms such as message queues or stream sockets, the FreeBSD’s IPC system is designed to be reliable and to ensure structured bi-directional communication amongst various local or remote processes.

- \textbf{Lesson 3:} Sockets allow processes to communicate through a network, even within computers with different operating systems. They provide the means for application data to flow through the networking layer, be received by a different process on a different machine, and flow into the application of the new receiving environment. 

- \textbf{Lesson 4:} Pipes are used in the shell for interprocess communication in a First-In-First-Out manner. It is a mechanism that allows process communication by sharing an unidirectional stream of data. 

- \textbf{Lesson 5:} Overall, the power of the FreeBSD IPC subsystem provides structured, secure and reliable mechanisms for interprocess communication, making it a popular option being widely used in the industry.


\begin{thebibliography}{00}
	% Using MLA9. If there are too many references, feel free to drop my manpage references %
	\bibitem{pipe} “FreeBSD Manual Pages.” Pipe(2), \href{https://man.freebsd.org/cgi/man.cgi?pipe\%282\%29}{https://man.freebsd.org/cgi/man.cgi?pipe\%282\%29}.
	\bibitem{fork} “FreeBSD Manual Pages.” Fork(2), \href{https://man.freebsd.org/cgi/man.cgi?fork(2)}{https://man.freebsd.org/cgi/man.cgi?fork(2)}.
	\bibitem{wait} “FreeBSD Manual Pages.” Wait(2), \href{https://man.freebsd.org/cgi/man.cgi?wait(2)}{https://man.freebsd.org/cgi/man.cgi?wait(2)}.
	\bibitem{close} “FreeBSD Manual Pages.” Close(2), \href{https://man.freebsd.org/cgi/man.cgi?query=close\&sektion=2}{https://man.freebsd.org/cgi/man.cgi?query=close\&sektion=2}.
	\bibitem{dup} “FreeBSD Manual Pages.” Dup(2), \href{https://man.freebsd.org/cgi/man.cgi?query=dup\&sektion=2\&n=1}{https://man.freebsd.org/cgi/man.cgi?query=dup\&sektion=2\&n=1}.
	\bibitem{execve} “FreeBSD Manual Pages.” Execve(2), \href{https://man.freebsd.org/cgi/man.cgi?query=execve\&sektion=2\&n=1}{https://man.freebsd.org/cgi/man.cgi?query=execve\&sektion=2\&n=1}.
	\bibitem{signal} “FreeBSD Manual Pages.” Signal(3), \href{https://man.freebsd.org/cgi/man.cgi?sektion=3\&query=signal}{https://man.freebsd.org/cgi/man.cgi?sektion=3\&query=signal}.
	\bibitem{pipe-explained} Menon-Sen, Abhijit. “How Are Unix Pipes Implemented?” Toroid.org, 27 Mar. 2020, \href{https://toroid.org/unix-pipe-implementation}{https://toroid.org/unix-pipe-implementation}.
\end{thebibliography}
\end{document}
