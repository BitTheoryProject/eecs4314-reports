#/usr/bin/perl
use strict;
use warnings;
use Data::Dumper;
use List::Util qw(first);


# todo: build out subsystems more accuratly, FreeBSD is structured with standard naming 
# practices so it's possible to build the subsystems from the existing modules.

# Create a containment file from generated TA and source
# Usage: perl gen-containment.pl <ta_dependency_file> <containment_file_name> <src_path>

# Change this to OS path seperator generated by Understand
my $s = "/";

# Subsystems and their components, todo: accept arg file with this format for flexibility
# Use glob patterns or substring match (default). 
# structure:
# {
#     "IPC.ss" => { <- hash 
#         "SYSTEMV.ss" => [ <- array
#             ["exact", "sys${s}kern${s}sysv_msg.c"], <- leafs are the paths/glob patterns in form ["type", "pattern"]. you can nest subsystems.
#             ["exact", "sys${s}kern${s}sysv_sem.c"],
#             ["exact", "sys${s}kern${s}sysv_shm.c"],
#             ["exact", "sys${s}kern${s}sysv_ipc.c"],
#         ],
#     }
# }
# Types:
# exact -> exact match pattern
# glob -> glob match pattern
# regex -> regex match pattern

# Examples:
# ${s}sys${s}kern${s}sys* -> match system kernel files
# ${s}sys${s}kern${s}uipc* -> match kernel ipc files
my $subsystems = {
    "IPC.ss" => {
            "SYSTEMV.ss" => [
                ["exact", "sys${s}kern${s}sysv_msg.c"],
                ["exact", "sys${s}kern${s}sysv_sem.c"],
                ["exact", "sys${s}kern${s}sysv_shm.c"],
                ["exact", "sys${s}kern${s}sysv_ipc.c"],
            ],
            "POSIX.ss" => [
                ["exact", "sys${s}kern${s}posix4_mib.c"],
            ],
            "MQUEUE.ss" => [
                ["exact", "sys${s}kern${s}uipc_mqueue.c"],
            ],
            "KQUEUE.ss" => [
                ["exact", "sys${s}kern${s}kern_event.c"],
                ["exact", "sys${s}kern${s}kern_kqueue.c"],
            ],
            "PTY.ss" => [
                ["exact", "sys${s}kern${s}tty_pty.c"],
                ["exact", "sys${s}kern${s}tty_tty.c"],
            ],
            "SIGNAL.ss" => [
                ["exact", "sys${s}kern${s}kern_sig.c"],
                ["exact", "sys${s}kern${s}kern_sigqueue.c"],
            ],
            "SOCKET.ss" => [
                ["exact", "sys${s}kern${s}uipc_domain.c"],
                ["exact", "sys${s}kern${s}uipc_mbuf.c"],
                ["exact", "sys${s}kern${s}uipc_socket.c"],
                ["exact", "sys${s}kern${s}uipc_socket2.c"],
            ],
            "PROCESS_MANAGEMENT.ss" => [
                ["exact", "sys${s}kern${s}kern_exit.c"],
                ["exact", "sys${s}kern${s}kern_fork.c"],
                ["exact", "sys${s}kern${s}kern_kthread.c"],
                ["exact", "sys${s}kern${s}kern_resource.c"],
                ["exact", "sys${s}kern${s}kern_sched.c"],
                ["exact", "sys${s}kern${s}kern_synch.c"],
            ],
        },
        "KERNEL.ss" => [
            ["exact", "sys${s}kern${s}sys_pipe.c"],
            ["exact", "sys${s}kern${s}sys_procdesc.c"],
            ["exact", "sys${s}kern${s}sys_process.c"],
            ["exact", "sys${s}kern${s}sys_socket.c"],
            ["exact", "sys${s}kern${s}syscalls.c"],
        ],
};

# Parse args
my ($ta_file, $contain_file, $src_path) = @ARGV;

# Read ta_dependency_file dependencies
my @dependencies;
open(my $fh, '<', $ta_file) or die "Could not open file '$ta_file': $!";
while (my $line = <$fh>) {
    chomp $line;
    if ($line =~ /^\s*$/) {
        next;
    }

    my ($type, $from, $to) = split(/\s+/, $line);
    # We only care about the concrete files
    if ($type eq "\$INSTANCE") {
        push @dependencies, $from;
    } 
}
close($fh);
my %dependencies_hash = map { $_ => 1 } @dependencies;

open my $cf, ">", $contain_file or die "Failed to open $contain_file: $!";

my @rootlevel;
my @toplevel;
my @lowlevel;
my $root = "freebsd";

# https://stackoverflow.com/questions/2363142/how-to-iterate-through-hash-of-hashes-in-perl
sub print_subsystem {
    my ($hash, $fn, $parent) = @_;
    my $new_parent = defined $parent ? "$parent" : "$root";
    while (my ($subsystem, $value) = each %$hash) {
        push @toplevel, "contain $new_parent $subsystem\n";
        if (ref $value eq "HASH") {
            print_subsystem($value, $fn, $subsystem);
        } elsif (ref $value eq "ARRAY"){
            foreach my $entry (@$value) {
                my @arr = @$entry;
                my $type = $arr[0];
                my $pattern = $arr[1];
                    
                if ($type eq "glob") {
                    # match pattern using glob
                    my @files = glob("${src_path}${pattern}");
                    if (@files) {
                        foreach my $match (@files) {
                            $match = substr $match, length($src_path);
                            # make sure file is a raw.ta instance
                            if (exists($dependencies_hash{"$root${s}$match"})) {
                                $fn->($subsystem, "$root${s}$match");
                            }
                        }
                    }
                } elsif ($type eq "regex") {
                    # match pattern using regex
                    my $match = first { $_ =~ $pattern } @dependencies;

                    if ($match) {
                        $fn->($subsystem, "$match");
                    } else {
                        # push @rootlevel, "contain $root $file";  
                    }
                } elsif ($type eq "exact") {
                    # match pattern exactly
                    if (grep { $_ eq "$root${s}$pattern" } @dependencies) {
                        $fn->($subsystem, "$root${s}$pattern");
                    } else {
                        # push @rootlevel, "contain $root $file";  
                    }
                } else {
                    die("Invalid pattern type: $type");
                }
            }
        }
    }
}

print_subsystem $subsystems, sub {
    my ($subsystem, $component ) = @_;
    # filter only c files (too many unneccessary files make process slow)
    if ($component =~ /\.(c|cpp|h)$/) {
        push @lowlevel, "contain $subsystem $component\n";
    }
};

# Print top level contains
for my $contain (@toplevel) {
    print $cf $contain
}
print $cf "\n\n";
# Print file level contains
for my $contain (@lowlevel) {
    print $cf $contain
}

# Should we print the files subsystems? We can discuss this.
# for my $contain (@rootlevel) {
    # print $root $contain
# }

close($cf);