#/usr/bin/perl
use strict;
use warnings;
use List::Util qw(first);
use JSON::PP;

# todo: build out subsystems more accuratly, FreeBSD is structured with standard naming 
# practices so it's possible to build the subsystems from the existing modules.

# Create a containment file from generated TA and source
# Usage: perl gen-containment.pl <ta_dependency_file> <containment_file_name> <src_path>

# Change this to OS path seperator generated by Understand
my $s = "/";

# Subsystems json file structure:
# {
#   "IPC.ss": { <- subsystem
#     "KQUEUE.ss": [ <- subystem
#       ["exact", "sys/kern/kern_event.c"], <- leaf in form ["exact"|"glob"|"regex", "pattern"], means the file matched by pattern is a component of parent
#       ["exact", "sys/kern/kern_kqueue.c"]
#     ],
#     "PTY.ss": [
#       ["exact", "sys/kern/tty_*.c"],
#     ]
#   }
# }
# Pattern types:
# exact -> exact match pattern
# glob -> glob match pattern
# regex -> regex match pattern

# Parse args
my ($ta_file, $contain_file, $src_path, $subsystems_file) = @ARGV;

# Read subsystems JSON
open(my $jf, '<', $subsystems_file) or die "Could not open file '$subsystems_file': $!";
my $json = do { local $/; <$jf> };
close($jf);

# Decode to hash
my $subsystems = decode_json($json);

# Read ta_dependency_file dependencies
my @dependencies;
open(my $df, '<', $ta_file) or die "Could not open file '$ta_file': $!";
while (my $line = <$df>) {
    chomp $line;
    if ($line =~ /^\s*$/) {
        next;
    }

    my ($type, $from, $to) = split(/\s+/, $line);
    # We only care about the concrete files
    if ($type eq "\$INSTANCE") {
        push @dependencies, $from;
    } 
}
close($df);
my %dependencies_hash = map { $_ => 1 } @dependencies;

open my $cf, ">", $contain_file or die "Failed to open $contain_file: $!";

my @rootlevel;
my @toplevel;
my @lowlevel;
my $root = "freebsd";

# https://stackoverflow.com/questions/2363142/how-to-iterate-through-hash-of-hashes-in-perl
sub print_subsystem {
    my ($hash, $fn, $parent) = @_;
    my $new_parent = defined $parent ? "$parent" : "$root";
    while (my ($subsystem, $value) = each %$hash) {
        push @toplevel, "contain $new_parent $subsystem\n";
        if (ref $value eq "HASH") {
            print_subsystem($value, $fn, $subsystem);
        } elsif (ref $value eq "ARRAY"){
            foreach my $entry (@$value) {
                my @arr = @$entry;
                my $type = $arr[0];
                my $pattern = $arr[1];
                    
                if ($type eq "glob") {
                    # match pattern using glob
                    my @files = glob("${src_path}${pattern}");
                    if (@files) {
                        foreach my $match (@files) {
                            $match = substr $match, length($src_path);
                            # make sure file is a raw.ta instance
                            if (exists($dependencies_hash{"$root${s}$match"})) {
                                $fn->($subsystem, "$root${s}$match");
                            }
                        }
                    }
                } elsif ($type eq "regex") {
                    # match pattern using regex
                    my $match = first { $_ =~ $pattern } @dependencies;

                    if ($match) {
                        $fn->($subsystem, "$match");
                    } else {
                        # push @rootlevel, "contain $root $file";  
                    }
                } elsif ($type eq "exact") {
                    # match pattern exactly
                    if (grep { $_ eq "$root${s}$pattern" } @dependencies) {
                        $fn->($subsystem, "$root${s}$pattern");
                    } else {
                        # push @rootlevel, "contain $root $file";  
                    }
                } else {
                    die("Invalid pattern type: $type");
                }
            }
        }
    }
}

# Recursivly build subystems
print_subsystem $subsystems, sub {
    my ($subsystem, $component ) = @_;
    # filter only c files (too many unneccessary files make process slow)
    if ($component =~ /\.(c|cpp|h)$/) {
        push @lowlevel, "contain $subsystem $component\n";
    }
};

# Print top level contains
for my $contain (@toplevel) {
    print $cf $contain
}
print $cf "\n\n";
# Print file level contains
for my $contain (@lowlevel) {
    print $cf $contain
}

# Should we print the files subsystems? We can discuss this.
# for my $contain (@rootlevel) {
    # print $root $contain
# }

close($cf);